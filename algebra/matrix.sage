load("algebra/polynomial.sage")
load("algebra/scalar_field.sage")
load("algebra/vector.sage")

class Matrix:

    def __init__(self, M, K, H, X):

        M = matrix(M)
        self.to_matrix = M

        if not isinstance(self.to_matrix, sage.matrix.matrix0.Matrix):
            print('Error: M is not a matrix.')
            assert(0)

        self.K = K
        self.H = H
        self.X = X
        self.sparse_norm = matrix_sparse_norm(self.to_matrix)# the number of non-zero entries in M

        if matrix_sparse_norm(self.to_matrix) != matrix_sparse_norm(M):
            print('Error: Sparse norm changed after zero padding.')
            assert(0)

        if self.K.order < self.sparse_norm:
            print('Error: The indexing group K is not large enough.')
            assert(0)

        self.K_to_RC = self.K_to_RC()
        self.R_to_H = self.R_to_H()
        self.C_to_H = self.C_to_H()

        self.row = self.row()
        self.col = self.col()
        self.val = self.val()


    def zero_pad(self, M):
        n = max(M.nrows(), M.ncols())
        R = matrix(n)
        for i in range(M.nrows()):
            for j in range(M.ncols()):
                R[i,j] = M[i,j]
        return R

        # Returns the group K generated by an element which is of order the minimal power of 2 which is at
    # least the sparse norm of M.
    def index_group(self):
        n = self.sparse_norm
        if n > Fstar.order():
            print('Error: Sparse norm of M is greater than |F*|.')
            assert(0)
        c = ceil(log(n, 2).n())
        P = get_root_of_unity(Fstar, c)
        while P == None and c <= prime_factors[0][1]:
            c+=1
            P = get_root_of_unity(Fstar, c)
        if c > prime_factors[0][1]:
            print('Error: 2^c is not a factor of |F*|.')
            assert(0)
        K = Fstar.subgroup([P]) # Set K = (P)
        return K

        # Returns an injective map of elements in K, the indexing group, to a matrix entry index (i, j) \in R x C.
    # Note R = {0, ..., M.nrows}, C = {0, ..., M.ncols}
    def K_to_RC(self):
        mapping = {}
        index=0
        # Maps group elements in K sequentially to a non-zero entry (i,j) in M
        for i in range(self.to_matrix.nrows()):
            for j in range(self.to_matrix.ncols()):
                if self.to_matrix[i,j] > 0:
                    mapping[self.K.to_list[index]] = (i,j)
                    index+=1
        return mapping

        # Returns an injective map from R to H.
    def R_to_H(self):
        mapping = {}
        # Injectively maps the row index in R to its corresponding group element in H
        for i in range(self.to_matrix.nrows()):
            mapping[i] = self.H.to_list[i]
        return mapping

        # Returns an injective map from C to H.
    def C_to_H(self):
        mapping = {}
        # Injectively maps the row index in C to its corresponding group element in H
        for i in range(self.to_matrix.ncols()):
            mapping[i] = self.H.to_list[i]
        return mapping

        # Returns the polynomial row_M: K -> H which is constructed by interpolating the points (k, h) \in K x H.
    def row(self):
        points = []
        for k in self.K.to_list:
            h = random_element(self.H.to_group)
            if k in self.K_to_RC.keys():
                h = self.R_to_H[self.K_to_RC[k][0]] # maps k to its corresponding row index, then sends the row index to its corresponding element in H
            points.append((F(k), F(h)))
        f = R.lagrange_polynomial(points)
        return f

    # Returns the polynomial col_M: K -> H which is constructed by interpolating the points (k, h) \in K x H.
    def col(self):
        points = []
        for k in self.K.to_list:
            h = random_element(self.H.to_group)
            if k in self.K_to_RC.keys():
                col_index = self.K_to_RC[k][1]
                col_index =  reindex_by_subdomain(self.H, self.X, col_index)
                h = self.C_to_H[col_index] # maps k to its corresponding col index, then sends the col index to its corresponding element in H
            points.append((F(k), F(h)))
        f = R.lagrange_polynomial(points)
        return f

    # Returns the normalized val_M: K -> F polynomial which is constructed by interpolating the points (k, m) and dividing by a constant.
    # In particular, val_M sends k is M[i,j] divided by u_H(row(k), row(k)) * u_H(col(k), col(k))
    def val(self):
        points = []
        for k in self.K.to_list:
            val = 0
            if k in self.K_to_RC.keys():
                (i, j) = self.K_to_RC[k]
                #val = self.to_matrix[i, j]
                u_row = self.H.order * self.row(x=k)^(self.H.order - 1)
                u_col = self.H.order * self.col(x=k)^(self.H.order - 1)
                val = self.to_matrix[i, j]  / (F(u_row) * F(u_col))
            points.append((F(k), val))
        f = R.lagrange_polynomial(points)
        return f

    # Returns the bivariate polynomial representation ofÂ matrix M evaluated at either x or y.
    # i.e. this will return a univariate polynomial of the form M(alpha, x) or M(x, beta) or M(alpha, beta).
    def bivariate_matrix_polynomial(self, X=None, Y=None, label=None, input_domain=None):
        if X == None and Y == None:
            print('Error: X and Y cannot both be None.')
            assert(0)
        poly = 0
        if X != None and Y == None:
            m = self.to_matrix
            variable_domain = self.H

            # TODO: this transpose generator should be a member function of Matrix
            transpose = [[None for _ in range(m.ncols())] for _ in range(m.nrows())] # TODO: order might be reversed
            for (row_index, row) in enumerate(m):
                for (col_index, val) in enumerate(row):
                    c_i = reindex_by_subdomain(variable_domain, input_domain, col_index)
                    transpose[c_i][row_index] = val

            m_at_alpha_evals = []
            for i in range(len(transpose)):
                sum_for_col = 0
                for j in range(len(transpose[i])):
                    val = transpose[i][j]
                    if val != 0:
                        assert(self.H.to_list[j] == self.K.to_list[j]) # TODO: this won't hold for all circuits, and then the groups below may need to be adjusted
                        k = self.K.to_list[j]
                        row_at_k = self.row(x=k)
                        l_row_at_x = d_vanishing_polynomial(self.H.to_group, row_at_k)
                        l_row_at_x = l_row_at_x * row_at_k / self.H.order
                        sum_for_col += val * l_row_at_x(x=X)
                m_at_alpha_evals.append(sum_for_col)
            poly = Vector(vector(m_at_alpha_evals), self.H).low_degree_extension

        else:
            print("unsupported option")
            assert(0)
        return poly


#Returns the sparse norm of the matrix M.
def matrix_sparse_norm(M):
    n = 0
    for i in range(M.nrows()):
        for j in range(M.ncols()):
            if M[i, j] > 0:
                n += 1
    return n

# Returns a matrix R that is M after zero-padding to an n x n matrix.
def zero_pad_matrix(M, n):
    if n < max(M.nrows(), M.ncols()):
        print('Error: M cannot be zero-padded to an n x n matrix.')
        assert(0)
    R = matrix(n)
    for i in range(M.nrows()):
        for j in range(M.ncols()):
            R[i,j] = M[i,j]
    return R