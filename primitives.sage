p = 79
F = GF(p)
R = PolynomialRing(F, 'x')
Fstar = F.unit_group()

"""
Algebraic Primitives, Part 1 

"""

# Returns element an element of group G of order n, where n is prime 
def element_order_p(p: int, G): 
    
    if not isinstance(G, sage.groups.group.Group): 
        print('Error: The input G is not a group.')
        exit(1)
        
    if not p.is_prime(): 
        print('Error: The input p is not prime.')
        exit(1)
    
    if G.order() % p != 0: 
        print('Error: The order p of the desired element does not divide order(G).')
        exit(1)
        
    # finds element of order p 
    g = G.random_element()
    h = g^(G.order()/p) 
    while h.order()==1: 
        g = G.random_element()
        h = g^(G.order()/p) 
    return h 

# Casts a group G = [g, g^2, ..., g^n=1] into a list of ambient group elements. 
def group_to_list(G):
    
    if not isinstance(G, sage.groups.group.Group): 
        print('Error: The input G is not a group.')
        exit(1)
        
    # returns a list out of the group elements 
    result = []
    g = G.0 
    for i in range(0, G.order()): 
        result.append(g**i)
    return result 

#Return the minimal degree vanishing polynomial over the subgroup H of F*. 
def vanishing_polynomial(S): 
    
    if isinstance(S, sage.groups.group.Group): 
        S = group_to_list(S)
        
    prod = R(1)
    for s in S:
        if s == F(0):
            prod *= R.lagrange_polynomial([(1, 1), (-1, -1)]) # = X 
        else: 
            prod *= R.lagrange_polynomial([(F(s), 0), (0, -F(s))])  # = prod*(X - s)     
    return prod 

# Returns the Lagrange polynomial defined over the set S contained in F* at point a \in F*. 
def lagrange_polynomial(S, a): 
    
    if isinstance(S, sage.groups.group.Group): 
        S = group_to_list(S) # 
    if a not in S: 
        print('Error: a is not an element of S.')
        exit(1)
        
    f = vanishing_polynomial(S)
    g=None
    if a == F(0): 
        g = R.lagrange_polynomial([(1, 1), (-1, -1)]) # = X
    else: 
        g = R.lagrange_polynomial([(F(a), 0), (0, -F(a))]) # = (X-a)
    if g == None: 
        print('Error: g is None')
        exit(1)
        
    q,r = f.quo_rem(g) 
    if r!=R(0): 
        print('Error: Remainder should be 0.')
        exit(1)
    if  f != q*g + r: 
        print('Error: Euclidean division failed.')
        exit(1)
    
    return q/q(x=a) 


class Group: 
    
    def __init__(self, G): 
        
        if not isinstance(G, sage.groups.group.Group): 
            print('Error: G is not a group object.')
            exit(1)
        
        self.to_group = G
        self.to_list = group_to_list(G)
        self.vanishing_polynomial = vanishing_polynomial(G)
        self.order = G.order()

class Vector: 
                                                                                                  
    def __init__(self, v):  
        
        if not isinstance(v, list): 
            print('Error: v is not a list.')
            exit(1)
        self.to_vector = vector(v)  
        self.H = Group(self.index_group()) 
        
        if len(v) > self.H.order: 
            print('Error: Unable to index as the order of H is less than len(v).')
            exit(1)
        
        self.norm = self.to_vector.norm() #L2 norm
        self.low_degree_extension = self.low_degree_extension()
        
        
    # Returns the index group K of matrix M generated by a kth root of unity, where k is prime. 
    # TODO: In the future, the order of K doesn't have to be prime. We have to find a primitive kth root of unity. 
    # to generate the group. 
    ## NOTE: For testing purposes, the groups in Rust and Sage have to be the same. 
    def index_group(self): 
        
        print('len z', len(self.to_vector))
        n = len(self.to_vector)
        if n > Fstar.order(): 
            print('Error: Length of vector is greater than |F*|.')
            exit(1)
    
        primes = factor(Fstar.order())
        next_prime=None
        
        # set next_prime equal to the smallest prime greater than n. 
        for i in range(len(primes)): 
            if primes[i][0] >= n: 
                print('prime', primes[i][0])
                next_prime = primes[i][0]
                break 
        if next_prime == None: 
            print("Error: No prime found.")
            exit(1)
            
        # find element in F* of order next_prime. 
        H_gen = element_order_p(next_prime, Fstar) 
        H = Fstar.subgroup([H_gen]) # set H = (h)
        return H
    
        
    # Returns the low degree extension of vector v.    
    # For testing purposes, assume there is a prime factor of |F*| which is equal to the length of v 
    def low_degree_extension(self):                                                                                            
        points = []
        for i, h in enumerate(self.H.to_list): 
            points.append((F(h), F(self.to_vector[i])))                                                                                                                                                                         
        f = R.lagrange_polynomial(points)
        return f
             






