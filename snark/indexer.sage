# -*- coding: utf-8 -*-
"""
Indexer class that takes in an R1CS constraint system and indexes it for Varuna PIOPs
"""

load("algebra/group.sage")
load("algebra/matrix.sage")
load("algebra/scalar_field.sage")

class Indexer:

    def __init__(self, A, B, C, z, w=None, x=None):
        (A, B, C, z, w_poly, x_poly) = self.zero_padding(A, B, C, z, w, x)
        n_A = matrix_sparse_norm(A)
        n_B = matrix_sparse_norm(B)
        n_C = matrix_sparse_norm(C)
        (K, K_A, K_B, K_C) = self.index_group_matrix(n_A, n_B, n_C)
        H = self.index_group_vector(len(z))
        W = self.index_group_vector(len(w))
        X = self.index_group_vector(len(x))
        self.K = Group(K)
        self.K_A = Group(K_A, ambient=K)
        self.K_B = Group(K_B, ambient=K)
        self.K_C = Group(K_C, ambient=K)
        self.H = Group(H)
        self.W = Group(W)
        self.X = Group(X)

        group_elements_to_file['K'] = self.K.to_list
        group_elements_to_file['K_A'] = self.K_A.to_list
        group_elements_to_file['K_B'] = self.K_B.to_list
        group_elements_to_file['K_C'] = self.K_C.to_list
        group_elements_to_file['H'] = self.H.to_list

        self.A = Matrix(A, self.K_A, self.H, self.X)
        self.B = Matrix(B, self.K_B, self.H, self.X)
        self.C = Matrix(C, self.K_C, self.H, self.X)
        self.z = Vector(z, self.H)
        self.w_poly = w_poly
        self.x_poly = x_poly


    # Note that, at the start, we have M.ncols() = len(z) by assumption (for the matrix-vector product to work).
    # First, we zero-pad z to the closest power of 2 that is at least len(z). Let z' be z after the zero-padding.
    # Next, we need to make M a square matrix. If M.nrows() <= len(z'), then we make M a square len(z') x len(z') matrix.
    # Otherwise (i.e. if M.nrows() > len(z')), we zero-pad z' to be of length M.nrows() and make M a square M.nrows() x M.nrows() matrix.
    # This ensures that H can index into [0, ..., M.nrows() - 1], [0, ..., M.ncols() - 1], and z'.
    def zero_padding(self, A, B, C, z, w=None, x=None):

        c = ceil(log(len(z), 2).n())
        z_prime_len = 2^c
        max_nrows = max(A.nrows(), B.nrows(), C.nrows())
        n = ceil(log(max(z_prime_len, max_nrows), 2).n())
        A = zero_pad_matrix(A, 2^n)
        B = zero_pad_matrix(B, 2^n)
        C = zero_pad_matrix(C, 2^n)
        z = zero_pad_vector(z, 2^n)

        # TODO: this code assumes we use square matrices
        # TODO: we should split computing x_poly and w_poly into a different function

        # compute x_poly and x_evals
        X = Group(self.index_group_vector(len(x)))
        x_vec = Vector(x, X)
        x_poly = x_vec.low_degree_extension
        var_domain = Group(self.index_group_vector(len(z)))
        x_evals = []
        for h in var_domain.to_list:
            x_evals.append(x_vec.low_degree_extension(x=h))

        # compute w_poly
        # pad w so that len(w) = len(z) - len(x)
        w = zero_pad_vector(w, 2^n - len(x))
        ratio = len(z) // len(x)
        w_evals = []
        for k in range(0, len(z)):
            if k % ratio == 0:
                w_evals.append(0)
            else:
                w_evals.append(w[k - (k // ratio) - 1] - x_evals[k])

        w_evals = Vector(w_evals, var_domain)
        w_poly = w_evals.low_degree_extension
        w_poly, r = w_poly.quo_rem(X.vanishing_polynomial())
        if r!= 0:
            print('Error: Remainder is non-zero.')
            assert(0)

        w_evals = []
        for h in var_domain.to_list:
            x_evals.append(x_vec.low_degree_extension(x=h))

        return (A, B, C, z, w_poly, x_poly)

    # Returns the indexing group K generated by an element which is of order the minimal power of 2 which is at least |M|.
    @staticmethod
    def index_group_matrix(n_A, n_B, n_C):
        n = max(n_A, n_B, n_C)
        if n > Fstar.order():
            print('Error: Maximum sparse norm is greater than |F*|.')
            assert(0)

        # Find subgroup K < F* generated by element of order 2^c
        c = ceil(log(n, 2).n())
        if Fstar.order() % 2^c != 0:
            print('Error: 2^c does not divide |F*|.')
            assert(0)
        P = get_root_of_unity(Fstar, c)
        while P == None and c < prime_factors[0][1]:
            c+=1
            P = get_root_of_unity(Fstar, c)
        if P == None:
            print('Error: No element found.')
            assert(0)

        K = Fstar.subgroup([P])

        # Find subgroup K_A < K generated by element of order 2^c_A
        c_A = ceil(log(n_A, 2).n())
        if Fstar.order() % 2^c_A != 0:
            print('Error: 2^c_A does not divide |F*|.')
            assert(0)
        P_A = get_root_of_unity(K, c_A)
        while P_A == None and c_A < c:
            c_A +=1
            P_A = get_root_of_unity(K, c_A)
        if P_A == None:
            P_A = P

        # Find subgroup K_B < K generated by element of order 2^c_B
        c_B = ceil(log(n_B, 2).n())
        if Fstar.order() % 2^c_B != 0:
            print('Error: 2^c_B does not divide |F*|.')
            assert(0)
        P_B = get_root_of_unity(K, c_B)
        while P_B == None and c_B < c:
            c_B +=1
            P_B = get_root_of_unity(K_B, c_B)
        if P_B == None:
            P_B = P

        # Find subgroup K_C < K generated by element of order 2^c_C
        c_C = ceil(log(n_C, 2).n())
        if Fstar.order() % 2^c_C != 0:
            print('Error: 2^c_C does not divide |F*|.')
            assert(0)
        P_C = get_root_of_unity(K, c_C)
        while P_C == None and c_C < c:
            c_C +=1
            P_C = get_root_of_unity(K, c_C)
        if P_C == None:
            P_C = P

        K_A = Fstar.subgroup([P_A]) # order 2^c_A
        K_B = Fstar.subgroup([P_B]) # order 2^c_B
        K_C = Fstar.subgroup([P_C]) # order 2^c_C

        return (K, K_A, K_B, K_C)


    # Returns the indexing group H generated by an element which is of order the minimal power of 2 which is at least len(v).
    # If 2^c > len(v), then v is zero padded to size 2^c.
    @staticmethod
    def index_group_vector(n):
        assert(n > 2) # this will return a weird cached object otherwise
        if n > Fstar.order():
            print('Error: Length of vector is greater than |F*|.')
            assert(0)

        c = ceil(log(n, 2).n())
        P = get_root_of_unity(Fstar, c)
        while P == None and c <= prime_factors[0][1]:
            c+=1
            P = get_root_of_unity(Fstar, c)

        if c > prime_factors[0][1]:
            print('Error: 2^c is not a factor of |F*|.')
            assert(0)

        H = Fstar.subgroup([P])
        return (H)