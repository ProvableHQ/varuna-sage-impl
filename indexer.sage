class Indexer: 
    
    def __init__(self, A, B, C, z):
        
        (A, B, C, z) = self.zero_padding(A, B, C, z)
        n_A = matrix_sparse_norm(A)
        n_B = matrix_sparse_norm(B)
        n_C = matrix_sparse_norm(C)
        (K, K_A, K_B, K_C) = self.index_group_matrix(n_A, n_B, n_C)
        
        self.K = Group(K)
        self.K_A = Group(K_A, K)
        self.K_B = Group(K_B, K)
        self.K_C = Group(K_C, K)
        self.H = Group(self.index_group_vector(len(z)))
        
        self.A = Matrix(A, self.K_A, self.H)
        self.B = Matrix(B, self.K_B, self.H)
        self.C = Matrix(C, self.K_C, self.H)
        self.z = Vector(z, self.H)
        
        
    # Note that, at the start, we have M.ncols() = len(z) by assumption (for the matrix-vector product to work). 
    # First, we zero-pad z to the closest power of 2 that is at least len(z). Let z' be z after the zero-padding. 
    # Next, we need to make M a square matrix. If M.nrows() <= len(z'), then we make M a square len(z') x len(z') matrix. 
    # Otherwise (i.e. if M.nrows() > len(z')), we zero-pad z' to be of length M.nrows() and make M a square M.nrows() x M.nrows() matrix. 
    # This ensures that H can index into [0, ..., M.nrows() - 1], [0, ..., M.ncols() - 1], and z'. 
    def zero_padding(self, A, B, C, z):
        H = self.index_group_vector(len(z)) 
        if log(H.order(), 2).n() not in ZZ: 
            print('Error: |H| is not a power of 2.')
            assert(0)
            
        z_prime_len = H.order()
        max_nrows = max(A.nrows(), B.nrows(), C.nrows()) 
        n = max(z_prime_len, max_nrows)
        
        A = zero_pad_matrix(A, n)
        B = zero_pad_matrix(B, n)
        C = zero_pad_matrix(C, n)
        z = zero_pad_vector(z, n)
        
        return (A, B, C, z)
            
    # Returns the indexing group K generated by an element which is of order the minimal power of 2 which is at least |M|. 
    @staticmethod
    def index_group_matrix(n_A, n_B, n_C): 
        n = max(n_A, n_B, n_C)
        if n > Fstar.order():
            print('Error: Maximum sparse norm is greater than |F*|.')
            assert(0)
        
        # Find subgroup K < F* generated by element of order 2^c 
        c = ceil(log(n, 2).n())
        if Fstar.order() % 2^c != 0: 
            print('Error: 2^c does not divide |F*|.')
            assert(0)   
        P = element_order_r(Fstar, c)
        while P == None and c < prime_factors[0][1]: 
            c+=1 
            P = element_order_r(Fstar, c)
        if P == None: 
            print('Error: No element found.')
            assert(0)
            
        K = Fstar.subgroup([P]) 
        
        # Find subgroup K_A < K generated by element of order 2^c_A
        c_A = ceil(log(n_A, 2).n())
        if Fstar.order() % 2^c_A != 0: 
            print('Error: 2^c_A does not divide |F*|.')
            assert(0)
        P_A = element_order_r(K, c_A)
        while P_A == None and c_A < c: 
            c_A +=1 
            P_A = element_order_r(K, c_A)
        if P_A == None: 
            P_A = P
        
        # Find subgroup K_B < K generated by element of order 2^c_B
        c_B = ceil(log(n_B, 2).n())
        if Fstar.order() % 2^c_B != 0: 
            print('Error: 2^c_B does not divide |F*|.')
            assert(0)
        P_B = element_order_r(K, c_B)
        while P_B == None and c_B < c: 
            c_B +=1 
            P_B = element_order_r(K_B, c_B)
        if P_B == None: 
            P_B = P
        
        # Find subgroup K_C < K generated by element of order 2^c_C
        c_C = ceil(log(n_C, 2).n())
        if Fstar.order() % 2^c_C != 0: 
            print('Error: 2^c_C does not divide |F*|.')
            assert(0)
        P_C = element_order_r(K, c_C)
        while P_C == None and c_C < c: 
            c_C +=1 
            P_C = element_order_r(K, c_C)
        if P_C == None: 
            P_C = P
        
        K_A = Fstar.subgroup([P_A]) # order 2^c_A
        K_B = Fstar.subgroup([P_B]) # order 2^c_B
        K_C = Fstar.subgroup([P_C]) # order 2^c_C
        
        return (K, K_A, K_B, K_C)
            
        
    # Returns the indexing group H generated by an element which is of order the minimal power of 2 which is at least len(v).
    # If 2^c > len(v), then v is zero padded to size 2^c. 
    @staticmethod 
    def index_group_vector(n): 
        if n > Fstar.order(): 
            print('Error: Length of vector is greater than |F*|.')
            assert(0)
        c = ceil(log(n, 2).n())
        P = element_order_r(Fstar, c)
        while P == None and c <= prime_factors[0][1]: 
            c+=1 
            P = element_order_r(Fstar, c)
        if c > prime_factors[0][1]: 
            print('Error: 2^c is not a factor of |F*|.')
            assert(0)
        H = Fstar.subgroup([P])
        return H